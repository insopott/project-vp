!function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.ReactLetterMorph = factory() : root.ReactLetterMorph = factory();
}("undefined" != typeof self ? self : this, function() {
    /******/
    return function(modules) {
        /******/
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: !1,
                /******/
                exports: {}
            };
            /******/
            /******/
            // Return the exports of the module
            /******/
            /******/
            /******/
            // Execute the module function
            /******/
            /******/
            /******/
            // Flag the module as loaded
            /******/
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.l = !0, module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/
        // Load entry module and return exports
        /******/
        /******/
        /******/
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/
        // expose the module cache
        /******/
        /******/
        /******/
        // define getter function for harmony exports
        /******/
        /******/
        /******/
        // getDefaultExport function for compatibility with non-harmony modules
        /******/
        /******/
        /******/
        // Object.prototype.hasOwnProperty.call
        /******/
        /******/
        /******/
        // __webpack_public_path__
        /******/
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.d = function(exports, name, getter) {
            /******/
            __webpack_require__.o(exports, name) || /******/
            Object.defineProperty(exports, name, {
                /******/
                configurable: !1,
                /******/
                enumerable: !0,
                /******/
                get: getter
            });
        }, __webpack_require__.n = function(module) {
            /******/
            var getter = module && module.__esModule ? /******/
            function() {
                return module.default;
            } : /******/
            function() {
                return module;
            };
            /******/
            /******/
            return __webpack_require__.d(getter, "a", getter), getter;
        }, __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _reactLetterMorph = __webpack_require__(1);
        Object.defineProperty(exports, "default", {
            enumerable: !0,
            get: function() {
                return _interopRequireDefault(_reactLetterMorph).default;
            }
        });
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !call || "object" != typeof call && "function" != typeof call ? self : call;
        }
        function _inherits(subClass, superClass) {
            if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass);
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }(), _react = __webpack_require__(2), _react2 = _interopRequireDefault(_react), _propTypes = __webpack_require__(3), _propTypes2 = _interopRequireDefault(_propTypes), _gsap = __webpack_require__(4), _reactStyleProptype = __webpack_require__(5), _reactStyleProptype2 = _interopRequireDefault(_reactStyleProptype), _lodash = __webpack_require__(6), _lodash2 = _interopRequireDefault(_lodash), _misc = __webpack_require__(7), DEFAULT_STYLE = {
            position: "relative"
        }, ReactLetterMorph = function(_Component) {
            function ReactLetterMorph(props) {
                _classCallCheck(this, ReactLetterMorph);
                // how fast to transiton
                var _this = _possibleConstructorReturn(this, (ReactLetterMorph.__proto__ || Object.getPrototypeOf(ReactLetterMorph)).call(this, props));
                // courseness of interpolation out of 100
                // dynamically updated
                return _this.transitionTime = 2, _this.interpolationPoint = {
                    percentage: 0
                }, _this.state = {
                    offset: 0,
                    paths: [],
                    // which one are we at rn?
                    pathIndex: 0,
                    // animation is undefined
                    animation: void 0
                }, _this.loop = _this.loop.bind(_this), _this.tweenPaths = _this.tweenPaths.bind(_this), 
                _this.interpolatePaths = _this.interpolatePaths.bind(_this), _this.getPaths = _this.getPaths.bind(_this), 
                _this.drawPathToCanvas = _this.drawPathToCanvas.bind(_this), _this.getColorSegment = _this.getColorSegment.bind(_this), 
                _this.resetAnimation = _this.resetAnimation.bind(_this), _this;
            }
            return _inherits(ReactLetterMorph, _Component), _createClass(ReactLetterMorph, [ {
                key: "componentDidMount",
                value: function() {
                    this.resetAnimation();
                }
            }, {
                key: "componentWillReceiveProps",
                value: function(nextProps) {
                    _lodash2.default.isEqual(this.props, nextProps) || this.resetAnimation();
                }
            }, {
                key: "getPaths",
                value: function() {
                    var _props = this.props, words = _props.words, fontUrl = _props.fontUrl, fontSize = _props.fontSize, steps = _props.steps;
                    return new Promise(function(resolve, reject) {
                        // eslint-disable-next-line global-require
                        __webpack_require__(8).load(fontUrl, function(err, font) {
                            if (err) reject(new Error("Failed to load font: " + err)); else {
                                var offsetY = 0;
                                // update offsetY
                                words.forEach(function(word) {
                                    var box = font.getPath(word, 0, 0, fontSize), y = box.getBoundingBox().y2 - box.getBoundingBox().y1;
                                    offsetY = Math.max(offsetY, y);
                                });
                                var paths = words.map(function(word) {
                                    // get the stroke from the font
                                    var pathStroke = font.getPath(word, 0, offsetY, fontSize).toPathData(2), path = (0, 
                                    _misc.getSvgPath)();
                                    path.setAttribute("d", pathStroke);
                                    var length = path.getTotalLength(), points = Array.from(Array(steps).keys()).map(function(i) {
                                        return path.getPointAtLength(length * i / steps);
                                    });
                                    return {
                                        length: length,
                                        path: points
                                    };
                                });
                                resolve(paths);
                            }
                        });
                    });
                }
            }, {
                key: "getColorSegment",
                value: function(index) {
                    var _props2 = this.props, colors = _props2.colors, steps = _props2.steps, offset = this.state.offset, p = index / steps + offset;
                    return p > 1 && (p -= 1), colors[Math.floor(p * colors.length)];
                }
            }, {
                key: "loop",
                value: function() {
                    if (this.canvas) {
                        var _state = this.state, paths = _state.paths, pathIndex = _state.pathIndex, offset = _state.offset, speed = this.props.speed;
                        if (this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), 
                        0 !== paths.length) {
                            var newOffset = offset + speed / paths[pathIndex].length;
                            newOffset = newOffset >= 1 ? 0 : newOffset, this.setState({
                                offset: newOffset
                            }, this.drawPathToCanvas), this.state.offset = newOffset, this.drawPathToCanvas();
                        }
                        requestAnimationFrame(this.loop);
                    }
                }
            }, {
                key: "resetAnimation",
                value: function() {
                    var _this2 = this, lineWidth = this.props.lineWidth;
                    this.getPaths().then(function(paths) {
                        _this2.setState({
                            paths: paths,
                            pathIndex: 0
                        }, function() {
                            if (_this2.canvas) {
                                var ctx = _this2.canvas.getContext("2d");
                                ctx.lineCap = "round", ctx.lineWidth = lineWidth, _this2.state.animation && _this2.state.animation.kill(), 
                                _this2.tweenPaths(), _this2.loop();
                            }
                        });
                    }).catch(function(error) {
                        console.error("Failed to get paths: " + error);
                    });
                }
            }, {
                key: "tweenPaths",
                value: function() {
                    var _this3 = this;
                    this.setState(function(prevState, props) {
                        return {
                            animation: _gsap.TweenLite.to(_this3.interpolationPoint, _this3.transitionTime, {
                                percentage: 1,
                                ease: _gsap.Power2.easeInOut,
                                delay: props.period,
                                onComplete: function() {
                                    _this3.interpolationPoint.percentage = 0, _this3.setState(function(ps) {
                                        return {
                                            pathIndex: ps.paths.length ? (ps.pathIndex + 1) % ps.paths.length : ps.pathIndex
                                        };
                                    }, _this3.tweenPaths);
                                }
                            })
                        };
                    });
                }
            }, {
                key: "drawPathToCanvas",
                value: function() {
                    var points = this.interpolatePaths(), currentColor = this.getColorSegment(0), ctx = this.canvas.getContext("2d");
                    ctx.strokeStyle = currentColor, ctx.beginPath();
                    // draw the points
                    for (var i = 0; i < points.length - 1; i += 1) ctx.moveTo(points[i].x, points[i].y), 
                    (!i || (0, _misc.distance)(points[i], points[i + 1]) <= 2 * (0, _misc.distance)(points[i], points[i - 1])) && (ctx.lineTo(points[i + 1].x, points[i + 1].y), 
                    // if its not the same color then start a new path withe the new color
                    (currentColor = this.getColorSegment(i)) !== ctx.strokeStyle && (ctx.stroke(), ctx.beginPath(), 
                    ctx.strokeStyle = currentColor));
                    ctx.stroke();
                }
            }, {
                key: "interpolatePaths",
                value: function() {
                    var _this4 = this, _state2 = this.state, paths = _state2.paths, pathIndex = _state2.pathIndex, steps = this.props.steps, from = paths[pathIndex % paths.length].path, to = paths[(pathIndex + 1) % paths.length].path;
                    return Array.from(Array(steps).keys()).map(function(i) {
                        return {
                            x: from[i].x + (to[i].x - from[i].x) * _this4.interpolationPoint.percentage,
                            y: from[i].y + (to[i].y - from[i].y) * _this4.interpolationPoint.percentage
                        };
                    });
                }
            }, {
                key: "render",
                value: function() {
                    var _this5 = this, _props3 = this.props, height = _props3.height, width = _props3.width, style = _props3.style;
                    return _react2.default.createElement("canvas", {
                        ref: function(canvas) {
                            _this5.canvas = canvas;
                        },
                        height: height,
                        width: width,
                        style: _extends({}, DEFAULT_STYLE, {
                            style: style
                        })
                    });
                }
            } ]), ReactLetterMorph;
        }(_react.Component);
        ReactLetterMorph.propTypes = {
            // height and width of the view port of the svg
            height: _propTypes2.default.number,
            width: _propTypes2.default.number,
            // words that are going to be morphed
            words: _propTypes2.default.arrayOf(_propTypes2.default.string).isRequired,
            // colors that will be rotated through
            colors: _propTypes2.default.arrayOf(_propTypes2.default.string),
            // font url
            fontUrl: _propTypes2.default.string,
            // fontSize of the words
            fontSize: _propTypes2.default.number,
            // width of the letter outlines
            lineWidth: _propTypes2.default.number,
            // period of the animation
            period: _propTypes2.default.number,
            // speed of the animation
            speed: _propTypes2.default.number,
            // style of the canvas element
            style: _reactStyleProptype2.default,
            // how many steps each period takes. Less == more efficient
            steps: _propTypes2.default.number
        }, ReactLetterMorph.defaultProps = {
            height: 200,
            width: 500,
            colors: [],
            fontUrl: "https://fonts.gstatic.com/s/pacifico/v9/yunJt0R8tCvMyj_V4xSjafesZW2xOQ-xsNqO47m55DA.woff",
            fontSize: 200,
            lineWidth: 2,
            period: 2,
            speed: 2,
            style: DEFAULT_STYLE,
            steps: 500
        }, exports.default = ReactLetterMorph;
    }, /* 2 */
    /***/
    function(module, exports) {
        module.exports = require("react");
    }, /* 3 */
    /***/
    function(module, exports) {
        module.exports = require("prop-types");
    }, /* 4 */
    /***/
    function(module, exports) {
        module.exports = require("gsap");
    }, /* 5 */
    /***/
    function(module, exports) {
        module.exports = require("react-style-proptype");
    }, /* 6 */
    /***/
    function(module, exports) {
        module.exports = require("lodash");
    }, /* 7 */
    /***/
    function(module, exports, __webpack_require__) {
        "use strict";
        function distance(pt1, pt2) {
            var x = pt1.x - pt2.x, y = pt1.y - pt2.y;
            return Math.sqrt(x * x + y * y);
        }
        function getSvgPath() {
            return document.createElementNS("http://www.w3.org/2000/svg", "path");
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.distance = distance, exports.getSvgPath = getSvgPath;
    }, /* 8 */
    /***/
    function(module, exports) {
        module.exports = require("opentype.js");
    } ]);
});